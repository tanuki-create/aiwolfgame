import type { 
  GameState, 
  GameEvent, 
  GameEventType, 
  TransitionResult,
  GamePhase 
} from '@aiwolf/shared';
import { AsyncMutex } from './utils/mutex.js';
import { isValidTransition, getNextPhase, requiresTimer } from './transitions.js';
import { PhaseTimer, calculateDeadline } from './timers.js';
import { HandlerRegistry } from './handlers/registry.js';

/**
 * Game Finite State Machine
 * Manages game state and phase transitions with serial execution guarantees
 */
export class GameFSM {
  private state: GameState;
  private mutex: AsyncMutex;
  private phaseTimer: PhaseTimer;
  private handlerRegistry: HandlerRegistry;
  private broadcastCallback?: (events: any[]) => Promise<void>;

  constructor(initialState: GameState) {
    this.state = initialState;
    this.mutex = new AsyncMutex();
    this.phaseTimer = new PhaseTimer();
    this.handlerRegistry = new HandlerRegistry();
    
    // Setup timer for initial phase if needed
    this.setupPhaseTimer();
  }

  /**
   * Set broadcast callback for state changes
   */
  setBroadcastCallback(callback: (events: any[]) => Promise<void>): void {
    this.broadcastCallback = callback;
  }

  /**
   * Get current game state (read-only)
   */
  getState(): Readonly<GameState> {
    return this.state;
  }

  /**
   * Transition to new state based on event
   * Ensures serial execution with mutex
   */
  async transition(event: GameEvent): Promise<TransitionResult> {
    return this.mutex.runExclusive(async () => {
      // Validate transition
      if (!isValidTransition(this.state.phase, event.type)) {
        throw new Error(
          `Invalid transition: ${event.type} from phase ${this.state.phase}`
        );
      }

      // Get handler for current phase and event
      const handler = this.handlerRegistry.getHandler(this.state.phase, event.type);
      
      if (!handler) {
        throw new Error(
          `No handler found for phase ${this.state.phase} and event ${event.type}`
        );
      }

      // Execute handler
      const result = await handler(this.state, event);

      // Update state
      this.state = result.nextState;

      // Setup timer for new phase
      this.setupPhaseTimer();

      // Broadcast events if callback set
      if (this.broadcastCallback && result.broadcast) {
        await this.broadcastCallback(result.broadcast);
      }

      // Process follow-up events asynchronously
      if (result.events && result.events.length > 0) {
        setImmediate(() => {
          this.processFollowUpEvents(result.events || []);
        });
      }

      return result;
    });
  }

  /**
   * Process follow-up events generated by a handler
   */
  private async processFollowUpEvents(events: GameEvent[]): Promise<void> {
    for (const event of events) {
      try {
        await this.transition(event);
      } catch (error) {
        console.error('Failed to process follow-up event:', event, error);
      }
    }
  }

  /**
   * Force transition to next phase (called by timer)
   */
  async forcePhaseTransition(eventType: GameEventType): Promise<TransitionResult> {
    return this.transition({
      type: eventType,
      timestamp: Date.now(),
      payload: { forced: true },
    });
  }

  /**
   * Setup automatic phase transition timer
   */
  private setupPhaseTimer(): void {
    // Clear any existing timer
    this.phaseTimer.clear();

    // Only setup timer for phases that need it
    if (!requiresTimer(this.state.phase)) {
      return;
    }

    // Determine which event should trigger when timer expires
    const nextEvent = this.getTimerEvent(this.state.phase);
    if (!nextEvent) {
      return;
    }

    // Start timer with warning callback
    this.phaseTimer.start(
      this.state.phaseDeadline, 
      () => {
        this.forcePhaseTransition(nextEvent).catch((error) => {
          console.error('Phase timer transition failed:', error);
        });
      },
      (remainingSeconds: number) => {
        // Send time warning to all players
        this.sendTimeWarning(remainingSeconds);
      }
    );
  }

  /**
   * Send time warning broadcast
   */
  private async sendTimeWarning(remainingSeconds: number): Promise<void> {
    const warningMessage = this.getWarningMessage(remainingSeconds);
    
    const broadcasts = [{
      type: 'SYSTEM_MESSAGE',
      payload: {
        message: warningMessage,
        timestamp: Date.now(),
      },
    }];

    if (this.broadcastCallback) {
      await this.broadcastCallback(broadcasts);
    }
  }

  /**
   * Get appropriate warning message based on remaining time
   */
  private getWarningMessage(remainingSeconds: number): string {
    const phaseNameMap: Record<GamePhase, string> = {
      'DAY_FREE_TALK': 'è­°è«–æ™‚é–“',
      'DAY_VOTE': 'æŠ•ç¥¨æ™‚é–“',
      'DAY_REVOTE_TALK': 'æœ€çµ‚å¼æ˜æ™‚é–“',
      'DAY_REVOTE': 'å†æŠ•ç¥¨æ™‚é–“',
      'LAST_WILL': 'éºè¨€æ™‚é–“',
      'NIGHT_WOLF_CHAT': 'ç‹¼ãƒãƒ£ãƒƒãƒˆæ™‚é–“',
      'NIGHT_ACTIONS': 'å¤œè¡Œå‹•æ™‚é–“',
      'DAWN': 'å¤œæ˜ã‘',
      'LOBBY': '',
      'INIT': '',
      'ASSIGN_ROLES': '',
      'CHECK_END': '',
      'GAME_OVER': '',
    };

    const phaseName = phaseNameMap[this.state.phase] || 'ãƒ•ã‚§ãƒ¼ã‚º';

    if (remainingSeconds === 60) {
      return `â° ${phaseName}æ®‹ã‚Š1åˆ†ã§ã™`;
    } else if (remainingSeconds === 30) {
      return `âš ï¸ ${phaseName}æ®‹ã‚Š30ç§’ã§ã™`;
    } else if (remainingSeconds === 10) {
      return `ğŸ”” ${phaseName}æ®‹ã‚Š10ç§’ã§ã™ï¼`;
    }
    
    return `â° ${phaseName}æ®‹ã‚Š${remainingSeconds}ç§’ã§ã™`;
  }

  /**
   * Get the event that should trigger when timer expires for a phase
   */
  private getTimerEvent(phase: GamePhase): GameEventType | null {
    switch (phase) {
      case 'DAY_FREE_TALK':
        return 'START_VOTE';
      case 'DAY_VOTE':
        return 'VOTE_COMPLETE';
      case 'DAY_REVOTE_TALK':
        return 'START_REVOTE';
      case 'DAY_REVOTE':
        return 'VOTE_COMPLETE';
      case 'LAST_WILL':
        return 'LAST_WILL_COMPLETE';
      case 'NIGHT_WOLF_CHAT':
        return 'START_NIGHT_ACTIONS';
      case 'NIGHT_ACTIONS':
        return 'RESOLVE_NIGHT';
      case 'DAWN':
        return 'DAWN_COMPLETE';
      default:
        return null;
    }
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    this.phaseTimer.clear();
  }
}

